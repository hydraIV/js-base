//1.    На сколько я понял, замыкания широко используются в различных JS-фреймворках (React, Vue, Angular...). При каждом новом вызове такой функции создается
//      новое лексическое окружение, при этом старое не удаляется. Можно хранить значения переменных.

//2.    
if (!("a" in window)) {
    var a = 1;
}
alert(a);
//undefined. При первом "проходе" интерпретатора будет создана глобальная переменная "a" (var a = 1). При втором проходе переменной "а" будет
//присвоена единица только если этой переменной нет в объекте window, т.е. она не объявлена глобально

var b = function a(x) {
    x && a(--x);
};
alert(a);
// Ничего, т.к. функция "a" объявлена в "b" и глобально можно использовать только "b" и не передается аргумент

function a(x) {
    return x * 2;
}
var a;
alert(a);
// Ничего, т.к. опять нет аргумента у функции "а", но все равно в alert вызывается функция. Не знаю почему

function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);
// 10. Функция "b" присваивает второму элементу массива аргументов функции значение 10.

function a() {
    alert(this);
}
a.call(null);
// null, т.к. this функции это window, а при вызове функции мы с помощью call указываем, что this "а" это null